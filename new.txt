// 1 Write a program to use fork system call to create 5 child processes and assign 5 operations
// to childs.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid;

    // Create 5 child processes
    for (int i = 0; i < 5; i++) {
        pid = fork();  // Create a new process

        if (pid < 0) {
            // If fork() fails
            perror("Fork failed");
            exit(1);
        } else if (pid == 0) {
            // Child processes
            switch (i) {
                case 0:
                    printf("Child %d: Performing Operation 1 (Printing message)\n", i + 1);
                    break;
                case 1:
                    printf("Child %d: Performing Operation 2 (Calculating 10 + 20)\n", i + 1);
                    printf("Result: 10 + 20 = %d\n", 10 + 20);
                    break;
                case 2:
                    printf("Child %d: Performing Operation 3 (Sleeping for 2 seconds)\n", i + 1);
                    sleep(2);
                    printf("Child %d: Woke up after 2 seconds\n", i + 1);
                    break;
                case 3:
                    printf("Child %d: Performing Operation 4 (Calculating 5 * 3)\n", i + 1);
                    printf("Result: 5 * 3 = %d\n", 5 * 3);
                    break;
                case 4:
                    printf("Child %d: Performing Operation 5 (Printing current process ID)\n", i + 1);
                    printf("Current Process ID: %d\n", getpid());
                    break;
            }
            exit(0);  // Terminate the child process after its task
        }
    }

    // Parent process waits for all child processes to complete
    for (int i = 0; i < 5; i++) {
        wait(NULL);  // Wait for child processes to finish
    }

    printf("Parent: All child processes have completed.\n");

    return 0;
}






// 2. Write a program to use vfork system call(login name by child and password by parent)

// #include <sys/types.h>  // For pid_t
#include <unistd.h>     // For vfork(), _exit()
#include <stdio.h>      // For printf, scanf
#include <stdlib.h>     // For exit()
#include <sys/wait.h>

int main() {
    char login[50];
    char password[50];

    pid_t pid = vfork();  // Create child using vfork()

    if (pid < 0) {
        perror("vfork failed");
        exit(1);
    } 
    else if (pid == 0) {
        // Child process
        printf("Child: Enter your login name: ");
        scanf("%s", login);
        _exit(0); // Use _exit() after vfork to immediately exit child
    } 
    else {
        // Parent process
        printf("Parent: Enter your password: ");
        scanf("%s", password);

        printf("\nLogin Details:\n");
        printf("Login Name: %s\n", login);
        printf("Password: %s\n", password);
    }

    return 0;
}



// 3. Write a program to open any application using fork sysem call.


#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<time.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>


int main(int argc,char *argv[])
{
    int pid=fork();
    if(pid==0)
    {
        printf("I am the child process\n");
        // execlp("Visual Studio Code","Visual Studio Code",NULL);
        // execlp("gedit","gedit",NULL);
        // execlp("firefox", "firefox", NULL);
        execlp("google-chrome","google-chrome",NULL);
        exit(0);

    }
}






//4. Write a program to open any application using vfork sysem call.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int pid = vfork();
    if (pid == 0) {
        // Child process
        execlp("gedit", "gedit", NULL);
        // If execlp fails, print an error message
        perror("execlp");
        // Terminate child process
        _exit(EXIT_FAILURE);
    } else if (pid > 0) {
        // Parent process
        // Wait for the child process to finish
        int status;
        waitpid(pid, &status, 0);
        printf("Child process finished\n");
    } else {
        // vfork() failed
        perror("vfork");
        exit(EXIT_FAILURE);
    }

    return 0;
}






//5. Write a program to demonstrate the wait use with fork sysem call.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    int status;

    pid = fork();  // Create a child process

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        // Child process
        printf("Child: My PID is %d\n", getpid());
        printf("Child: I am going to sleep for 5 seconds...\n");
        sleep(5);  // Simulate some work
        printf("Child: I am exiting now.\n");
        exit(0);
    }
    else {
        // Parent process
        printf("Parent: My child's PID is %d\n", pid);
        printf("Parent: Waiting for child to finish...\n");

        wait(&status);  // Parent waits for child

        if (WIFEXITED(status)) {
            printf("Parent: Child exited with status %d\n", WEXITSTATUS(status));
        } else {
            printf("Parent: Child did not exit normally.\n");
        }

        printf("Parent: Now continuing with parent process.\n");
    }

    return 0;
}








//6. Write a program to demonstrate the variations exec system call.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    int choice;
    
    printf("Choose an exec variation to demonstrate:\n");
    printf("1. execl()\n");
    printf("2. execv()\n");
    printf("3. execlp()\n");
    printf("4. execvp()\n");
    printf("Enter choice: ");
    scanf("%d", &choice);

    pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        // Child process
        switch (choice) {
            case 1:
                printf("Child: Using execl() to open /bin/ls\n");
                execl("/bin/ls", "ls", "-l", (char *)NULL);
                perror("execl failed");
                exit(1);
            case 2:
                printf("Child: Using execv() to open /bin/ls\n");
                {
                    char *args[] = {"ls", "-a", NULL};
                    execv("/bin/ls", args);
                    perror("execv failed");
                    exit(1);
                }
            case 3:
                printf("Child: Using execlp() to open ls\n");
                execlp("ls", "ls", "-lh", (char *)NULL);
                perror("execlp failed");
                exit(1);
            case 4:
                printf("Child: Using execvp() to open ls\n");
                {
                    char *args[] = {"ls", "-R", NULL};
                    execvp("ls", args);
                    perror("execvp failed");
                    exit(1);
                }
            default:
                printf("Invalid choice.\n");
                exit(1);
        }
    }
    else {
        // Parent process
        wait(NULL);
        printf("Parent: Child process finished.\n");
    }

    return 0;
}






// 7. Write a program to demonstrate the exit system call use with wait & fork sysem call.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    int status;

    pid = fork();  // Create a child process

    if (pid < 0) {
        // Fork failed
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        // Child process
        printf("Child: My PID is %d\n", getpid());
        printf("Child: I am going to exit with status 42...\n");

        // Exit with a specific status code
        exit(42);  // Exit status is 42
    }
    else {
        // Parent process
        printf("Parent: My child's PID is %d\n", pid);
        printf("Parent: Waiting for child to finish...\n");

        wait(&status);  // Parent waits for child to finish

        // Check if child exited normally
        if (WIFEXITED(status)) {
            // Get the exit status of the child
            printf("Parent: Child exited normally with status %d\n", WEXITSTATUS(status));
        } else {
            printf("Parent: Child did not exit normally.\n");
        }

        printf("Parent: Now continuing with parent process.\n");
    }

    return 0;
}




08. two codes open in two terminals
// Write a program to demonstrate the kill system call to send signals between unrelated process

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>  // Add this header for wait() function


void signal_handler(int signum) {
    if (signum == SIGUSR1) {
        printf("Process %d received SIGUSR1 signal\n", getpid());
    }
}

int main() {
    pid_t pid1, pid2;

    // Register signal handler for SIGUSR1
    signal(SIGUSR1, signal_handler);

    // Fork to create two processes
    pid1 = fork();
    if (pid1 < 0) {
        perror("fork failed");
        exit(1);
    }

    if (pid1 == 0) {
        // Child Process 1
        printf("Child Process 1: My PID is %d\n", getpid());
        // Wait for the signal from another process
        pause();  // Wait for a signal to be delivered
        exit(0);
    } else {
        // Fork again to create another unrelated process (Child Process 2)
        pid2 = fork();
        if (pid2 < 0) {
            perror("fork failed");
            exit(1);
        }

        if (pid2 == 0) {
            // Child Process 2
            printf("Child Process 2: My PID is %d\n", getpid());
            // Wait for the signal from the parent or another process
            pause();  // Wait for a signal to be delivered
            exit(0);
        } else {
            // Parent Process
            printf("Parent: Sending SIGUSR1 signal to Child Process 1 (PID: %d)\n", pid1);
            sleep(2);  // Just to ensure that Child Process 1 is waiting for the signal
            kill(pid1, SIGUSR1);  // Send SIGUSR1 to Child Process 1

            printf("Parent: Sending SIGUSR1 signal to Child Process 2 (PID: %d)\n", pid2);
            sleep(2);  // Just to ensure that Child Process 2 is waiting for the signal
            kill(pid2, SIGUSR1);  // Send SIGUSR1 to Child Process 2

            // Wait for both child processes to finish
            wait(NULL);
            wait(NULL);
            printf("Parent: Both child processes have finished.\n");
        }
    }

    return 0;
}





// 9. Write a program to demonstrate the kill system call to send signals between related
// processes(fork).

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

void signal_handler(int signum) {
    if (signum == SIGUSR1) {
        printf("Child: Received SIGUSR1 signal\n");
    }
}

int main() {
    pid_t pid;

    // Register signal handler for SIGUSR1
    signal(SIGUSR1, signal_handler);

    pid = fork();  // Create a child process

    if (pid < 0) {
        // Fork failed
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0) {
        // Child process
        printf("Child: My PID is %d\n", getpid());
        printf("Child: Waiting for the SIGUSR1 signal...\n");
        pause();  // Wait for the signal from parent
        exit(0);
    }
    else {
        // Parent process
        printf("Parent: My child's PID is %d\n", pid);
        sleep(2);  // Ensure child is ready to receive signal

        printf("Parent: Sending SIGUSR1 signal to Child process\n");
        kill(pid, SIGUSR1);  // Send SIGUSR1 signal to the child process

        // Wait for the child process to finish
        wait(NULL);
        printf("Parent: Child process has finished.\n");
    }

    return 0;
}









// 10. Write a program to use alarm and signal sytem call(check i/p from user within time)
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

int time_out_flag = 0;  // Flag to check if time has expired

// Signal handler for SIGALRM
void handle_alarm(int signum) {
    time_out_flag = 1;  // Set the flag to indicate timeout
    printf("\nTime is up! You did not input in time.\n");
    exit(0);  // Exit the program after timeout
}

int main() {
    char input[100];

    // Register signal handler for SIGALRM
    signal(SIGALRM, handle_alarm);

    // Set the alarm to go off in 10 seconds
    alarm(10);

    // Ask for user input
    printf("You have 10 seconds to enter your input: ");
    fgets(input, sizeof(input), stdin);  // Get user input

    // If user input is received before timeout, cancel the alarm
    if (!time_out_flag) {
        // Cancel the alarm if input is received before timeout
        alarm(0);
        printf("Your input: %s\n", input);
        printf("Input received successfully within the time limit!\n");
    }

    return 0;
}





//11. Write a program for alarm clock using alarm and signal system call.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

// Signal handler for SIGALRM
void handle_alarm(int signum) {
    printf("\nTime's up! The alarm is ringing now!\n");
    exit(0);  // Exit the program after the alarm goes off
}

int main() {
    int seconds;

    // Register signal handler for SIGALRM
    signal(SIGALRM, handle_alarm);

    // Ask user to set the alarm time in seconds
    printf("Set an alarm time in seconds: ");
    scanf("%d", &seconds);

    // Set the alarm to go off after the specified number of seconds
    alarm(seconds);

    // Inform the user that the alarm has been set
    printf("Alarm has been set for %d seconds. Waiting...\n", seconds);

    // Wait for the alarm to go off
    while (1) {
        // Program is waiting for the alarm signal to be triggered
        sleep(1);
    }

    return 0;
}






// 12. Write a program to give statistics of a given file using stat system call. (few imp field like
// FAP, file type)


#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>

// Function to print file permissions
void print_permissions(mode_t mode) {
    printf("Permissions: ");
    
    // User permissions
    printf((mode & S_IRUSR) ? "r" : "-");
    printf((mode & S_IWUSR) ? "w" : "-");
    printf((mode & S_IXUSR) ? "x" : "-");
    
    // Group permissions
    printf((mode & S_IRGRP) ? "r" : "-");
    printf((mode & S_IWGRP) ? "w" : "-");
    printf((mode & S_IXGRP) ? "x" : "-");
    
    // Other permissions
    printf((mode & S_IROTH) ? "r" : "-");
    printf((mode & S_IWOTH) ? "w" : "-");
    printf((mode & S_IXOTH) ? "x" : "-");
    
    printf("\n");
}

// Function to print file type
void print_file_type(mode_t mode) {
    printf("File Type: ");
    if (S_ISREG(mode)) {
        printf("Regular File\n");
    } else if (S_ISDIR(mode)) {
        printf("Directory\n");
    } else if (S_ISLNK(mode)) {
        printf("Symbolic Link\n");
    } else if (S_ISCHR(mode)) {
        printf("Character Device\n");
    } else if (S_ISBLK(mode)) {
        printf("Block Device\n");
    } else if (S_ISFIFO(mode)) {
        printf("FIFO (Named Pipe)\n");
    } else if (S_ISSOCK(mode)) {
        printf("Socket\n");
    } else {
        printf("Unknown File Type\n");
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <file_path>\n", argv[0]);
        return 1;
    }

    struct stat file_stat;

    // Get file statistics
    if (stat(argv[1], &file_stat) == -1) {
        perror("stat failed");
        return 1;
    }

    // Print file type
    print_file_type(file_stat.st_mode);

    // Print file size
    printf("File Size: %ld bytes\n", file_stat.st_size);

    // Print file permissions
    print_permissions(file_stat.st_mode);

    // Print last access time
    printf("Last Access Time (atime): %s", ctime(&file_stat.st_atime));

    // Print last modification time
    printf("Last Modification Time (mtime): %s", ctime(&file_stat.st_mtime));

    // Print last status change time
    printf("Last Status Change Time (ctime): %s", ctime(&file_stat.st_ctime));

    return 0;
}





//13.  Write a program to give statistics of a given file using fstat system call. (few imp field like
// FAP, file type)

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>

// Function to print file permissions
void print_permissions(mode_t mode) {
    printf("Permissions: ");
    
    // User permissions
    printf((mode & S_IRUSR) ? "r" : "-");
    printf((mode & S_IWUSR) ? "w" : "-");
    printf((mode & S_IXUSR) ? "x" : "-");
    
    // Group permissions
    printf((mode & S_IRGRP) ? "r" : "-");
    printf((mode & S_IWGRP) ? "w" : "-");
    printf((mode & S_IXGRP) ? "x" : "-");
    
    // Other permissions
    printf((mode & S_IROTH) ? "r" : "-");
    printf((mode & S_IWOTH) ? "w" : "-");
    printf((mode & S_IXOTH) ? "x" : "-");
    
    printf("\n");
}

// Function to print file type
void print_file_type(mode_t mode) {
    printf("File Type: ");
    if (S_ISREG(mode)) {
        printf("Regular File\n");
    } else if (S_ISDIR(mode)) {
        printf("Directory\n");
    } else if (S_ISLNK(mode)) {
        printf("Symbolic Link\n");
    } else if (S_ISCHR(mode)) {
        printf("Character Device\n");
    } else if (S_ISBLK(mode)) {
        printf("Block Device\n");
    } else if (S_ISFIFO(mode)) {
        printf("FIFO (Named Pipe)\n");
    } else if (S_ISSOCK(mode)) {
        printf("Socket\n");
    } else {
        printf("Unknown File Type\n");
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <file_path>\n", argv[0]);
        return 1;
    }

    // Open the file
    int fd = open(argv[1], O_RDONLY);
    if (fd == -1) {
        perror("Error opening file");
        return 1;
    }

    struct stat file_stat;

    // Get file statistics using fstat
    if (fstat(fd, &file_stat) == -1) {
        perror("fstat failed");
        close(fd);
        return 1;
    }

    // Print file type
    print_file_type(file_stat.st_mode);

    // Print file size
    printf("File Size: %ld bytes\n", file_stat.st_size);

    // Print file permissions
    print_permissions(file_stat.st_mode);

    // Print last access time
    printf("Last Access Time (atime): %s", ctime(&file_stat.st_atime));

    // Print last modification time
    printf("Last Modification Time (mtime): %s", ctime(&file_stat.st_mtime));

    // Print last status change time
    printf("Last Status Change Time (ctime): %s", ctime(&file_stat.st_ctime));

    // Close the file descriptor
    close(fd);

    return 0;
}






//14 Write a multithreaded program in JAVA for chatting.

Server
import java.io.*;
import java.net.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class ChatServer {
    private static final int PORT = 1234;
    private static CopyOnWriteArrayList<ClientHandler> clients = new CopyOnWriteArrayList<>();

    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("Server is listening on port " + PORT);
            
            while (true) {
                Socket socket = serverSocket.accept();
                ClientHandler clientThread = new ClientHandler(socket);
                clients.add(clientThread);
                clientThread.start();
            }
        } catch (IOException ex) {
            System.out.println("Server exception: " + ex.getMessage());
            ex.printStackTrace();
        }
    }

    static void broadcast(String message, ClientHandler excludeUser) {
        for (ClientHandler aClient : clients) {
            if (aClient != excludeUser) {
                aClient.sendMessage(message);
            }
        }
    }

    static void removeClient(ClientHandler client) {
        clients.remove(client);
        if (client.getUserName() != null) {
            System.out.println("The client [" + client.getUserName() + "] disconnected");
            broadcast("The client [" + client.getUserName() + "] has left the chat.", null);
        }
    }

    static class ClientHandler extends Thread {
        private Socket socket;
        private PrintWriter writer;
        private String userName;

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        public void run() {
            try {
                InputStream input = socket.getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(input));
                OutputStream output = socket.getOutputStream();
                writer = new PrintWriter(output, true);

                String userName = reader.readLine();
                this.userName = userName;
                String serverMessage = "New user connected: " + userName;
                System.out.println(serverMessage);
                ChatServer.broadcast(serverMessage, this);

                String clientMessage;

                do {
                    clientMessage = reader.readLine();
                    serverMessage = "[" + userName + "]: " + clientMessage;
                    ChatServer.broadcast(serverMessage, this);

                } while (!clientMessage.equals("bye"));

                ChatServer.removeClient(this);
                socket.close();

            } catch (IOException ex) {
                System.out.println("Error in UserThread: " + ex.getMessage());
                ex.printStackTrace();
            }
        }

        void sendMessage(String message) {
            writer.println(message);
        }

        String getUserName() {
            return this.userName;
        }
    }
}



Client
import java.io.*;
import java.net.*;

public class ChatClient {
    private String userName;
    private String hostname = "localhost";  
    private int port = 1234;   

    public ChatClient() {
        
    }

    public void execute() {
        try {
            Socket socket = new Socket(hostname, port);
            System.out.println("Connected to the chat server");

            new ReadThread(socket, this).start();
            new WriteThread(socket, this).start();

        } catch (UnknownHostException ex) {
            System.out.println("Server not found: " + ex.getMessage());
        } catch (IOException ex) {
            System.out.println("I/O Error: " + ex.getMessage());
        }
    }

    void setUserName(String userName) {
        this.userName = userName;
    }

    String getUserName() {
        return this.userName;
    }

    public static void main(String[] args) {
       
        ChatClient client = new ChatClient();
        client.execute();
    }

    static class ReadThread extends Thread {
        private BufferedReader reader;
        private Socket socket;
        private ChatClient client;

        public ReadThread(Socket socket, ChatClient client) {
            this.socket = socket;
            this.client = client;

            try {
                InputStream input = socket.getInputStream();
                reader = new BufferedReader(new InputStreamReader(input));
            } catch (IOException ex) {
                System.out.println("Error getting input stream: " + ex.getMessage());
                ex.printStackTrace();
            }
        }

        public void run() {
            while (true) {
                try {
                    String response = reader.readLine();
                    System.out.println("\n" + response);

                    // Prompt current user to enter their message right after displaying new messages
                    if (client.getUserName() != null) {
                        System.out.print("[" + client.getUserName() + "]: ");
                    }
                } catch (IOException ex) {
                    System.out.println("Error reading from server: " + ex.getMessage());
                    ex.printStackTrace();
                    break;
                }
            }
        }
    }

    static class WriteThread extends Thread {
        private PrintWriter writer;
        private Socket socket;
        private ChatClient client;

        public WriteThread(Socket socket, ChatClient client) {
            this.socket = socket;
            this.client = client;

            try {
                OutputStream output = socket.getOutputStream();
                writer = new PrintWriter(output, true);
            } catch (IOException ex) {
                System.out.println("Error getting output stream: " + ex.getMessage());
                ex.printStackTrace();
            }
        }

        public void run() {
            Console console = System.console();
            String userName = console.readLine("\nEnter your name: ");
            client.setUserName(userName);
            writer.println(userName);

            String text;

            do {
                text = console.readLine("[" + userName + "]: ");
                writer.println(text);

            } while (!text.equals("bye"));

            try {
                socket.close();
            } catch (IOException ex) {
                System.out.println("Error writing to server: " + ex.getMessage());
            }
        }
    }
}





asignment15
// Write a program to create 3 threads, first thread printing even no, second thread printing odd no.
// and third thread printing prime no.

import java.io.*;

class odd extends Thread {

    public void run()
    {
        for(int i=1;i<=10;i++)
        {
            if(i%2!=0)
            {
                System.out.println("Odd: "+i);
            }
        }
    }
}

class even extends Thread
{
    public void run()
    {
        for(int i=1;i<=10;i++)
        {
            if(i%2==0)
            {
                System.out.println("Even: "+i);
            }
        }
    }

}

class prime extends Thread
{
    public void run()
    {
        for(int i=1;i<=10;i++)
        {
            int count=0;
            for(int j=1;j<=i;j++)
            {
                if(i%j==0)
                {
                    count++;
                }
            }
            if(count==2)
            {
                System.out.println("Prime: "+i);
            }
        }
    }
}
public class assignment15
{
    public static void main(String [] args)
    {
        odd o=new odd();
        even e=new even();
        prime p=new prime();
        o.start();
        e.start();
        p.start();
    }
}





16. Write a multithread program in linux to use the pthread library

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_THREADS 2
#define NUM_INCREMENTS 1000000

// Shared global counter
int counter = 0;

// Mutex for synchronizing access to the counter
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Function for the threads to execute
void *thread_function(void *arg) {
    int i;
    for (i = 0; i < NUM_INCREMENTS; i++) {
        // Lock the mutex before accessing the shared counter
        pthread_mutex_lock(&mutex);
        
        // Increment the counter
        counter++;
        
        // Unlock the mutex after accessing the shared counter
        pthread_mutex_unlock(&mutex);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    int i, status;

    // Create thread s
    for (i = 0; i < NUM_THREADS; i++) {
        status = pthread_create(&threads[i], NULL, thread_function, NULL);
        if (status != 0) {
            fprintf(stderr, "Error creating thread %d. Exiting...\n", i);
            exit(EXIT_FAILURE);
        }
    }

    // Join threads
    for (i = 0; i < NUM_THREADS; i++) {
        status = pthread_join(threads[i], NULL);
        if (status != 0) {
            fprintf(stderr, "Error joining thread %d. Exiting...\n", i);
            exit(EXIT_FAILURE);
        }
    }

    // Print the final value of the counter
    printf("Final counter value: %d\n", counter);

    return 0;
}






// 17. producer consumer problem in java using multiThreading

import java.util.LinkedList;

class ProducerConsumer {
    private LinkedList<Integer> buffer = new LinkedList<>();
    private int capacity;

    public ProducerConsumer(int capacity) {
        this.capacity = capacity;
    }

    public void produce() throws InterruptedException {
        int value = 0;
        while (true) {
            synchronized (this) {
                while (buffer.size() == capacity) {
                    wait();
                }

                System.out.println("Producer produced: " + value);
                buffer.add(value++);
                notify();

                Thread.sleep(1000);
            }
        }
    }

    public void consume() throws InterruptedException {
        while (true) {
            synchronized (this) {
                while (buffer.isEmpty()) {
                    wait();
                }

                int value = buffer.removeFirst();
                System.out.println("Consumer consumed: " + value);
                notify();

                Thread.sleep(1000);
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ProducerConsumer pc = new ProducerConsumer(5);

        Thread producerThread = new Thread(() -> {
            try {
                pc.produce();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread consumerThread = new Thread(() -> {
            try {
                pc.consume();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producerThread.start();
        consumerThread.start();
    }
}






18. calculator code


#!/bin/bash

echo "Simple Calculator"
echo "------------------"
echo "Choose an operation:"
echo "1. Add"
echo "2. Subtract"
echo "3. Multiply"
echo "4. Divide"
echo "5. Exit"

while true; do
    # Prompt for the choice
    read -p "Enter your choice (1-5): " choice
    
    # Exit the script if user chooses 5
    if [ "$choice" -eq 5 ]; then
        echo "Goodbye!"
        break
    fi
    
    # Ask for two numbers
    read -p "Enter first number: " num1
    read -p "Enter second number: " num2
    
    # Perform the chosen operation
    case $choice in
        1)
            result=$((num1 + num2))
            echo "Result: $result"
            ;;
        2)
            result=$((num1 - num2))
            echo "Result: $result"
            ;;
        3)
            result=$((num1 * num2))
            echo "Result: $result"
            ;;
        4)
            if [ "$num2" -eq 0 ]; then
                echo "Error: Division by zero!"
            else
                result=$((num1 / num2))
                echo "Result: $result"
            fi
            ;;
        *)
            echo "Invalid choice, please choose a number between 1 and 5."
            ;;
    esac
done





digital 

#19.  Write a program to implement digital clock using shell script.
#!/bin/bash

while true; 
do
    clear
    echo "$(date +"%T")"
    sleep 1
done





# 20. Write a program to check whether system is in network or not using ’ping’ command using shell
# script.
#!/bin/bash

# Define the IP address or domain name to ping
target="www.google.com"

# Ping the target
ping -c 1 $target 

# Check the exit status of the ping command
if [ $? == 0 ]; then
    echo "System is connected to the network."
else
    echo "System is not connected to the network."
fi






# 21. Write a program to sort 10 the given 10 numbers in ascending order using shell.

#!/bin/bash

echo "Sorting 10 numbers using shell..."

myarr=(10 9 8 7 6 5 4 3 2 1)

for ((i = 0; i < 10; i++)); do
    min_index=$i
    for ((j = i + 1; j < 10; j++)); do
        if [[ ${myarr[j]} -lt ${myarr[min_index]} ]]; then
            min_index=$j
        fi
    done
    if [[ $min_index -ne $i ]]; then
        temp=${myarr[i]}
        myarr[i]=${myarr[min_index]}
        myarr[min_index]=$temp
    fi
done

echo "Sorted numbers in ascending order:"
for ((i = 0; i < 10; i++)); do
    echo "${myarr[i]}"
done





# 22. Write a program to print “Hello World” message in bold, blink effect, and in different colors like
# red, blue etc.

#!/bin/bash

# ANSI escape codes for formatting
BOLD='\033[1m'
BLINK='\033[5m'
RED='\033[31m'
BLUE='\033[34m'
RESET='\033[0m'

# Print "Hello World" in bold, blink effect, and in different colors

while true; do
    echo -e "${BOLD}${BLINK}${RED}Hello World${RESET}"
    sleep 1
    echo -e "${BOLD}${BLINK}${BLUE}Hello World${RESET}"
    sleep 1
done





# 23. Write a shell script to find whether given file exist or not in folder or on drive.

#!/bin/bash

# Ask the user for the file name
read -p "Enter the file name to search: " filename

# Ask the user for the directory to start searching (can be / for whole drive)
read -p "Enter the directory to search in (e.g., /home/user or /): " directory

# Check if the directory exists
if [ ! -d "$directory" ]; then
  echo "Directory does not exist."
  exit 1
fi

# Use 'find' command to search for the file
found=$(find "$directory" -type f -name "$filename" 2>/dev/null)

if [ -n "$found" ]; then
  echo "File found at:"
  echo "$found"
else
  echo "File not found."
fi






# 24. Write a shell script to show the disk partitions and their size and disk usage i.e free space.

#!/bin/bash

# Display disk partitions and their sizes
echo "Disk partitions and their sizes:"
df -h

# Display disk usage (free space)
echo "Disk usage (free space):"
du -h /





# 25. Write a shell script to find the given file in the system using find or locate command.

#!/bin/bash

# Main program
echo "Enter the name of the file to search:"
read file_to_search

echo "Searching for '$file_to_search' using find command:"
find / -name "$file_to_search" 2>/dev/null






# 26 & 27. Write a shell script to download a webpage from given URL . (Using wget command).


#!/bin/bash

# Main program
echo "Enter the URL of the webpage to download:"
read url

echo "Downloading webpage from '$url'..."

# Download the webpage using wget command
wget "$url" -O webpage.html

echo "Webpage downloaded successfully!"






#28. Write a shell script to display the users on the system . (Using finger or who command).


#!/bin/bash

# Display the users on the system using the who command
echo "Users currently logged in to the system:"
who


assignment 29
# Write a python recursive function for prime number input limit in as parameter to
# it.

def is_prime(n, divisor=2):
    if n < 2:
        return False
    if divisor * divisor > n:
        return True
    if n % divisor == 0:
        return False
    return is_prime(n, divisor + 1)

def print_primes(limit, current=2):
    if current > limit:
        return
    if is_prime(current):
        print(current, end=' ')
    print_primes(limit, current + 1)

# Example usage:
limit = int(input("Enter the limit: "))
print(f"Prime numbers up to {limit}:",end=' ')
print_primes(limit)
print()


assignment 30:
. Write a program to display the following pyramid. The number of lines in the
pyramid should not be hard-coded. It should be obtained from the user. The
pyramid should appear as close to the center of the screen as possible.
(Hint: Basics n loops)

cpp code-
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
    int numLines;
    
    cout << "Enter the number of lines in the pyramid: ";
    cin >> numLines;
    
    // Display the pyramid
    for(int i = 1; i <= numLines; ++i) {
        // Print leading spaces
        cout << setw(numLines - i + 1);
        
        // Print left half of the pyramid
        for(int j = 1; j <= i; ++j) {
            cout << j << " ";
        }
        
        // Print right half of the pyramid
        for(int j = i - 1; j >= 1; --j) {
            cout << j << " ";
        }
        
        cout << endl;
    }
    
    return 0;
}
python code-
# Get the number of lines from the user
lines = int(input("Enter the number of lines for the pyramid: "))

# Loop through each line
for i in range(1, lines + 1):
    # Print spaces
    print(' ' * (lines - i),end='')
    # Print stars
    print('*' * (2 * i - 1))


31. take any txt file and count word frequencies in a file.(hint : file handling + basics )

import string 
# Ask the user for the filename
filename = input("Enter the filename (with .txt extension): ")

# Create an empty dictionary to store word counts
word_count = {}

try:
    # Open the file in read mode
    with open(filename, 'r') as file:
        # Read the entire file content
        text = file.read()
        
        # Remove all punctuations using translate
        translator = str.maketrans('', '', string.punctuation)
        text = text.translate(translator)
        
        # Split text into words
        words = text.split()

        # Count each word
        for word in words:
            word = word.lower()  # Convert to lowercase for uniform counting
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1

    # Print the word frequencies
    print("\nWord Frequencies:\n")
    for word, count in word_count.items():
        print(f"{word}: {count}")

except FileNotFoundError:
    print("File not found. Please check the file name and try again.")



Gedit command_frequnecy.py
python command_frequency.py



32. Generate a frequency list of all the commands you have used, and show the top 5 commands along with their count. (Hint: history command hist will give you a list of all commands used.)

import os
from collections import Counter

def get_bash_history_commands():
    history_file = os.path.expanduser("~/.bash_history")
    with open(history_file, "r", encoding="utf-8") as file:
        commands = file.readlines()
    return [command.strip() for command in commands if command.strip()]

commands = get_bash_history_commands()
command_freq = Counter(commands)

print("Top 5 commands:")
for command, count in command_freq.most_common(5):
    print(f"{count}: {command}")

gedit command_frequency.py
python3 command_frequency.py



33. Write a shell script that will take a filename as input and check if it is executable. 2. Modify the script in the previous question, to remove the execute permissions, if the file is executable.

To accomplish this objective, we can write a shell script that takes a filename as input and checks if it is executable. If the file is executable, the script will remove its execute permissions. Here's the shell script:

#!/bin/bash

# Function to check if a file is executable and remove execute permissions if it is
check_and_remove_execute_permissions() {
    filename="$1"
    
    # Check if the file is executable
    if [ -x "$filename" ]; then
        echo "$filename is executable."
        # Remove execute permissions
        chmod -x "$filename"
        echo "Execute permissions removed from $filename."
    else
        echo "$filename is not executable."
    fi
}

# Main script
# Check if filename is provided as argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi

# Get the filename from command-line argument
filename="$1"

# Call the function to check and remove execute permissions
check_and_remove_execute_permissions "$filename"

gedit check_permissions.sh
chmod +x check_permissions.sh
./check_permissions.sh filename(filename give exec file to check permission)

34. Generate a word frequency list for wonderland.txt. Hint: use grep, tr, sort, uniq (or anything else that you want)

Just take wonderland.txt and directly run this

grep -oE '\b\w+\b' wonderland.txt | tr '[:upper:]' '[:lower:]' | sort | uniq -c

Use this command where wonderland.txt is novel so it will give word frequency list for wonderland.txt

35. Write a bash script that takes 2 or more arguments, i)All arguments are filenames ii)If fewer than two arguments are given, print an error message iii)If the files do not exist, print error message iv)Otherwise concatenate files 

#!/bin/bash

# Function to concatenate files
concatenate_files() {
    # Concatenate all files into a new file named "output.txt"
    cat "$@" > output.txt
    echo "Files concatenated successfully. Result saved in output.txt"
}

# Main script
# Check if at least two filenames are provided as arguments
if [ $# -lt 2 ]; then
    echo "Error: At least two filenames are required."
    exit 1
fi

# Check if all provided filenames exist
for filename in "$@"; do
    if [ ! -e "$filename" ]; then
        echo "Error: File '$filename' does not exist."
        exit 1
    fi
done

# Call the function to concatenate files
concatenate_files "$@"


Save filename concat_files.sh
Create any file1.txt file2.txt 
chmod +x concat_files.sh
./concat_files.sh file1.txt file2.txt file3.txt ...





36. Write a python function for merge/quick sort for integer list as parameter to it.
merge

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # Split the array into two halves
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    # Recursively sort each half
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    # Merge the sorted halves
    return merge(left_half, right_half)

def merge(left, right):
    merged = []
    left_index = right_index = 0
    
    # Merge the two halves into a single sorted array
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    
    # Add remaining elements from left or right half
    merged.extend(left[left_index:])
    merged.extend(right[right_index:])
    
    return merged

# Input from the user
n = int(input("Enter the number of integers: "))
input_str = input(f"Enter {n} space-separated integers: ")
arr = [int(x) for x in input_str.split()]

# Check if the number of integers provided is equal to n
if len(arr) != n:
    print(f"Error: Expected {n} integers.")
else:
    # Sort the array using merge sort
    sorted_arr = merge_sort(arr)
    print("Sorted array:", sorted_arr)

Gedit merge.py
Python3 merge.py


Quick

def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

# Input from the user
n = int(input("Enter the number of integers: "))
input_str = input(f"Enter {n} space-separated integers: ")
arr = [int(x) for x in input_str.split()]

# Check if the number of integers provided is equal to n
if len(arr) != n:
    print(f"Error: Expected {n} integers.")
else:
    # Sort the array using quick sort
    sorted_arr = quick_sort(arr)
    print("Sorted array:", sorted_arr)
Gedit quick.py
Python3 quick.py

37. Write a shell script to download a given file from ftp://10.10.13.16 if it exists on ftp. (use lftp, get and mget commands). 

You can use the lftp command-line tool to achieve this. Below is a shell script that downloads a given file from the FTP server at ftp://10.10.13.16 if it exists:

#!/bin/bash

# Function to download a file from FTP
download_file() {
    # FTP URL and filename
    ftp_url="ftp://10.10.13.16"
    filename="$1"

    # Check if the file exists on FTP
    echo "Checking if $filename exists on FTP..."
    if lftp -e "find $filename; exit" "$ftp_url" | grep -q "$filename"; then
        # Download the file
        echo "Downloading $filename from FTP..."
        lftp -e "get $filename; exit" "$ftp_url"
        echo "Download complete."
    else
        echo "Error: $filename does not exist on FTP."
    fi
}

# Main script
# Check if filename is provided as argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi

# Get the filename from command-line argument
filename="$1"

# Call the function to download the file from FTP
download_file "$filename”

Gedit download_from_ftp.sh
chmod +x download_from_ftp.sh
./download_from_ftp.sh filename(filename you want to download from ftp)


38. Write program to implement producer consumer problem using semaphore.h in C/JAVA

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

pthread_t *producers;
pthread_t *consumers;
sem_t buf_mutex, empty_count, fill_count;
int *buf, buf_pos = -1, prod_count, con_count, buf_len;

int produce(pthread_t self) {
    int i = 0;
    int p = 1 + rand() % 40;
    while (!pthread_equal(*(producers + i), self) && i < prod_count) {
        i++;
    }
    printf("Producer %d produced %d \n", i + 1, p);
    return p;
}

void consume(int p, pthread_t self) {
    int i = 0;
    while (!pthread_equal(*(consumers + i), self) && i < con_count) {
        i++;
    }
    printf("Buffer:");
    for (i = 0; i <= buf_pos; ++i)
        printf("%d ", *(buf + i));
    printf("\nConsumer %d consumed %d \nCurrent buffer len: %d\n", i + 1, p, buf_pos);
}

void* producer(void *args) {
    while (1) {
        int p = produce(pthread_self());
        sem_wait(&empty_count);
        sem_wait(&buf_mutex);
        ++buf_pos; // critical section
        *(buf + buf_pos) = p;
        sem_post(&buf_mutex);
        sem_post(&fill_count);
        sleep(1 + rand() % 3);
    }
    return NULL;
}

void* consumer(void *args) {
    int c;
    while (1) {
        sem_wait(&fill_count);
        sem_wait(&buf_mutex);
        c = *(buf + buf_pos);
        consume(c, pthread_self());
        --buf_pos;
        sem_post(&buf_mutex);
        sem_post(&empty_count);
        sleep(1 + rand() % 5);
    }
    return NULL;
}

int main(void) {
    int i, err;
    srand(time(NULL));
    sem_init(&buf_mutex, 0, 1);
    sem_init(&fill_count, 0, 0);
    printf("Enter the number of Producers:");
    scanf("%d", &prod_count);
    producers = (pthread_t*) malloc(prod_count * sizeof(pthread_t));
    printf("Enter the number of Consumers:");
    scanf("%d", &con_count);
    consumers = (pthread_t*) malloc(con_count * sizeof(pthread_t));
    printf("Enter buffer capacity:");
    scanf("%d", &buf_len);
    buf = (int*) malloc(buf_len * sizeof(int));
    sem_init(&empty_count, 0, buf_len);
    for (i = 0; i < prod_count; i++) {
        err = pthread_create(producers + i, NULL, &producer, NULL);
        if (err != 0) {
            fprintf(stderr, "Error creating producer %d: %s\n", i + 1, strerror(err));
        } else {
            printf("Successfully created producer %d\n", i + 1);
        }
    }
    for (i = 0; i < con_count; i++) {
        err = pthread_create(consumers + i, NULL, &consumer, NULL);
        if (err != 0) {
            fprintf(stderr, "Error creating consumer %d: %s\n", i + 1, strerror(err));
        } else {
            printf("Successfully created consumer %d\n", i + 1);
        }
    }
    for (i = 0; i < prod_count; i++) {
        pthread_join(*(producers + i), NULL);
    }
    for (i = 0; i < con_count; i++) {
        pthread_join(*(consumers + i), NULL);
    }
    return 0;
}
gedit producer_consumer.c
gcc -pthread producer_consumer.c -o producer_consumer
./producer_consumer


39. Write a program to implement reader-writers problem using semaphore.  

The reader-writers problem involves multiple readers and writers accessing a shared resource (e.g., a file, database, etc.). Readers can access the resource simultaneously, while writers must have exclusive access to the resource. We can use semaphores to solve this problem by ensuring that writers have exclusive access while allowing multiple readers to access the resource concurrently.

Here's a basic implementation of the reader-writers problem using semaphores in C:

c
Copy code
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define NUM_READERS 3
#define NUM_WRITERS 2

sem_t mutex, write_block;
int data = 0, reader_count = 0;

void *reader(void *arg) {
    int reader_id = *(int *)arg;
    while (1) {
        sem_wait(&mutex);
        reader_count++;
        if (reader_count == 1) {
            sem_wait(&write_block);
        }
        sem_post(&mutex);

        printf("Reader %d read data: %d\n", reader_id, data);

        sem_wait(&mutex);
        reader_count--;
        if (reader_count == 0) {
            sem_post(&write_block);
        }
        sem_post(&mutex);
    }
    pthread_exit(NULL);
}

void *writer(void *arg) {
    int writer_id = *(int *)arg;
    while (1) {
        sem_wait(&write_block);
        data++;
        printf("Writer %d wrote data: %d\n", writer_id, data);
        sem_post(&write_block);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t readers[NUM_READERS], writers[NUM_WRITERS];
    int reader_ids[NUM_READERS], writer_ids[NUM_WRITERS];
    int i;

    // Initialize semaphores
    sem_init(&mutex, 0, 1);
    sem_init(&write_block, 0, 1);

    // Create reader threads
    for (i = 0; i < NUM_READERS; i++) {
        reader_ids[i] = i + 1;
        pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
    }

    // Create writer threads
    for (i = 0; i < NUM_WRITERS; i++) {
        writer_ids[i] = i + 1;
        pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
    }

    // Join reader threads
    for (i = 0; i < NUM_READERS; i++) {
        pthread_join(readers[i], NULL);
    }

    // Join writer threads
    for (i = 0; i < NUM_WRITERS; i++) {
        pthread_join(writers[i], NULL);
    }

    // Destroy semaphores
    sem_destroy(&mutex);
    sem_destroy(&write_block);

    return 0;
}
Gedit reader_writers.c
gcc -pthread reader_writers.c -o reader_writers
./reader_writers



40. Write a program for chatting between two/three users to demonstrate IPC using message passing (msgget, msgsnd, msgrcv ).  

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>
#include <errno.h>

#define MAX_MSG 256
#define QUEUE_KEY 1234

// Message structure
struct msg_buffer {
    long msg_type; // Receiver ID (1, 2, or 3)
    int sender_id; // Sender ID
    char msg_text[MAX_MSG];
};

void print_prompt(int user_id) {
    printf("User %d: ", user_id);
    fflush(stdout);
}

int main() {
    int msgid;
    struct msg_buffer message;
    char buffer[MAX_MSG];
    int user_id;

    // Get user ID (1, 2, or 3)
    printf("Enter your User ID (1, 2, or 3): ");
    scanf("%d", &user_id);
    getchar(); // Clear newline from input buffer

    if (user_id < 1 || user_id > 3) {
        printf("Invalid User ID. Must be 1, 2, or 3.\n");
        exit(1);
    }

    // Create or access message queue
    msgid = msgget(QUEUE_KEY, 0666 | IPC_CREAT);
    if (msgid == -1) {
        perror("msgget failed");
        exit(1);
    }

    printf("User %d, you can start chatting. Type 'exit' to quit.\n", user_id);

    // Fork to handle sending and receiving concurrently
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) { // Child process: Receive messages
        while (1) {
            // Receive message for this user (msg_type = user_id)
            if (msgrcv(msgid, &message, sizeof(message.sender_id) + sizeof(message.msg_text), user_id, 0) == -1) {
                perror("msgrcv failed");
                exit(1);
            }

            // Clear the current prompt line
            printf("\033[K\r");

            // Print received message to append below previous ones
            if (strcmp(message.msg_text, "exit") == 0) {
                printf("User %d has left the chat.\n", message.sender_id);
            } else {
                printf("User %d: %s\n", message.sender_id, message.msg_text);
            }

            // Redisplay the prompt
            print_prompt(user_id);
        }
    } else { // Parent process: Send messages
        while (1) {
            // Display prompt
            print_prompt(user_id);

            // Get input from user
            if (fgets(buffer, MAX_MSG, stdin) == NULL) {
                continue;
            }
            buffer[strcspn(buffer, "\n")] = 0; // Remove newline

            // Prepare message
            message.sender_id = user_id;
            strncpy(message.msg_text, buffer, MAX_MSG);

            // Send message to all users (1, 2, 3)
            for (int i = 1; i <= 3; i++) {
                if (i != user_id) { // Don't send to self
                    message.msg_type = i;
                    if (msgsnd(msgid, &message, sizeof(message.sender_id) + sizeof(message.msg_text), 0) == -1) {
                        perror("msgsnd failed");
                        exit(1);
                    }
                }
            }

            // Check for exit condition
            if (strcmp(buffer, "exit") == 0) {
                printf("Exiting chat...\n");
                break;
            }
        }

        // Clean up: Remove message queue when the last user exits
        if (msgctl(msgid, IPC_RMID, NULL) == -1) {
            perror("msgctl failed");
        }
    }

    return 0;
}
 gedit message_queue.c
gcc message_queue.c -o message_queue
./message_queue


41.Write a program to demonstrate IPC using shared memory (shmget, shmat,
shmdt). In this, one process will send A to Z/1 to 100 as input from user and another
process will receive it.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>

#define SHM_KEY 5678
#define MAX_SIZE 1024

// Structure for shared memory
struct shared_memory {
    int written; // Flag: 1 if sender has written, 0 if receiver has read
    char data[MAX_SIZE]; // Data buffer
};

int main() {
    int shmid;
    struct shared_memory *shm;
    pid_t pid;

    // Create shared memory
    shmid = shmget(SHM_KEY, sizeof(struct shared_memory), 0666 | IPC_CREAT);
    if (shmid == -1) {
        perror("shmget failed");
        exit(1);
    }

    // Fork to create sender and receiver processes
    pid = fork();

    if (pid == -1) {
        perror("fork failed");
        exit(1);
    }

    if (pid > 0) { // Parent process: Sender
        // Attach shared memory
        shm = (struct shared_memory *)shmat(shmid, NULL, 0);
        if (shm == (void *)-1) {
            perror("shmat failed");
            exit(1);
        }

        char choice;
        printf("Sender: Choose input type (A for A-Z, N for 1-100): ");
        scanf(" %c", &choice);
        getchar(); // Clear newline

        if (choice != 'A' && choice != 'N') {
            printf("Invalid choice. Exiting.\n");
            shmdt(shm);
            shmctl(shmid, IPC_RMID, NULL);
            exit(1);
        }

        // Wait until shared memory is free (written == 0)
        while (shm->written == 1) {
            sleep(1);
        }

        // Prepare data based on choice
        if (choice == 'A') {
            char *ptr = shm->data;
            for (char c = 'A'; c <= 'Z'; c++) {
                *ptr++ = c;
            }
            *ptr = '\0'; // Null-terminate
        } else { // choice == 'N'
            char *ptr = shm->data;
            for (int i = 1; i <= 100; i++) {
                ptr += sprintf(ptr, "%d ", i);
            }
        }

        // Mark as written
        shm->written = 1;

        printf("Sender: Data written to shared memory.\n");

        // Detach shared memory
        if (shmdt(shm) == -1) {
            perror("shmdt failed");
            exit(1);
        }

        // Wait for receiver to finish
        wait(NULL);

        // Remove shared memory
        if (shmctl(shmid, IPC_RMID, NULL) == -1) {
            perror("shmctl failed");
            exit(1);
        }
    } else { // Child process: Receiver
        // Attach shared memory
        shm = (struct shared_memory *)shmat(shmid, NULL, 0);
        if (shm == (void *)-1) {
            perror("shmat failed");
            exit(1);
        }

        // Wait until data is written (written == 1)
        while (shm->written == 0) {
            sleep(1);
        }

        // Read and print data
        printf("Receiver: Data received from shared memory: %s\n", shm->data);

        // Mark as read
        shm->written = 0;

        // Detach shared memory
        if (shmdt(shm) == -1) {
            perror("shmdt failed");
            exit(1);
        }
    }

    return 0;
}
/*
Commands
gcc -o filename filename.c
./filename

*/


42. Write a program to demonstrate IPC using shared memory (shmget, shmat,
shmdt). In this, one process will send from file A to Z/1 to 100 as input from user
and another process will receive it in file. (use same directory and different name
files)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>

#define SHM_KEY 6789
#define MAX_SIZE 1024
#define INPUT_FILE "input.txt"
#define OUTPUT_FILE "output.txt"

// Structure for shared memory
struct shared_memory {
    int written; // Flag: 1 if sender has written, 0 if receiver has read
    char data[MAX_SIZE]; // Data buffer
};

int main() {
    int shmid;
    struct shared_memory *shm;
    pid_t pid;

    // Create shared memory
    shmid = shmget(SHM_KEY, sizeof(struct shared_memory), 0666 | IPC_CREAT);
    if (shmid == -1) {
        perror("shmget failed");
        exit(1);
    }

    // Fork to create sender and receiver processes
    pid = fork();

    if (pid == -1) {
        perror("fork failed");
        exit(1);
    }

    if (pid > 0) { // Parent process: Sender
        // Attach shared memory
        shm = (struct shared_memory *)shmat(shmid, NULL, 0);
        if (shm == (void *)-1) {
            perror("shmat failed");
            exit(1);
        }

        char choice;
        printf("Sender: Choose input type (A for A-Z, N for 1-100): ");
        scanf(" %c", &choice);
        getchar(); // Clear newline

        if (choice != 'A' && choice != 'N') {
            printf("Invalid choice. Exiting.\n");
            shmdt(shm);
            shmctl(shmid, IPC_RMID, NULL);
            exit(1);
        }

        // Open input file
        FILE *input_fp = fopen(INPUT_FILE, "r");
        if (input_fp == NULL) {
            perror("Failed to open input file");
            shmdt(shm);
            shmctl(shmid, IPC_RMID, NULL);
            exit(1);
        }

        // Read data from file
        if (fgets(shm->data, MAX_SIZE, input_fp) == NULL) {
            printf("Error reading from input file or file is empty.\n");
            fclose(input_fp);
            shmdt(shm);
            shmctl(shmid, IPC_RMID, NULL);
            exit(1);
        }
        fclose(input_fp);

        // Remove trailing newline if present
        shm->data[strcspn(shm->data, "\n")] = '\0';

        // Validate input based on choice
        // if (choice == 'A' && strcmp(shm->data, "ABCDEFGHIJKLMNOPQRSTUVWXYZ") != 0) {
        //     printf("Input file does not contain A-Z.\n");
        //     shmdt(shm);
        //     shmctl(shmid, IPC_RMID, NULL);
        //     exit(1);
        // } else if (choice == 'N') {
        //     // Basic validation for numbers (check if it starts with "1 ")
        //     if (strncmp(shm->data, "1 ", 2) != 0) {
        //         printf("Input file does not contain 1-100.\n");
        //         shmdt(shm);
        //         shmctl(shmid, IPC_RMID, NULL);
        //         exit(1);
        //     }
        // }

        // Wait until shared memory is free (written == 0)
        while (shm->written == 1) {
            sleep(1);
        }

        // Mark as written
        shm->written = 1;

        printf("Sender: Data written to shared memory from %s.\n", INPUT_FILE);

        // Detach shared memory
        if (shmdt(shm) == -1) {
            perror("shmdt failed");
            exit(1);
        }

        // Wait for receiver to finish
        wait(NULL);

        // Remove shared memory
        if (shmctl(shmid, IPC_RMID, NULL) == -1) {
            perror("shmctl failed");
            exit(1);
        }
    } else { // Child process: Receiver
        // Attach shared memory
        shm = (struct shared_memory *)shmat(shmid, NULL, 0);
        if (shm == (void *)-1) {
            perror("shmat failed");
            exit(1);
        }

        // Wait until data is written (written == 1)
        while (shm->written == 0) {
            sleep(1);
        }

        // Open output file
        FILE *output_fp = fopen(OUTPUT_FILE, "w");
        if (output_fp == NULL) {
            perror("Failed to open output file");
            shmdt(shm);
            exit(1);
        }

        // Write data to file
        fprintf(output_fp, "%s\n", shm->data);
        fclose(output_fp);

        printf("Receiver: Data received from shared memory and written to %s.\n", OUTPUT_FILE);

        // Mark as read
        shm->written = 0;

        // Detach shared memory
        if (shmdt(shm) == -1) {
            perror("shmdt failed");
            exit(1);
        }
    }

    return 0;
}
/*
Commands
gcc -o filename filename.c
./filename

*/
43. Write a program to demonstrate IPC using shared memory (shmget, shmat, shmdt). In
this, one process will take numbers as input from user and second process will sort the
numbers and put back to shared memory. Third process will display the shared memory.
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/wait.h>

#define SHM_SIZE 1024

int main() {
    int shmid;
    key_t key;
    int *shm, *s;

    // Create a unique key
    key = ftok(".", 's');
    if (key == -1) {
        perror("ftok");
        exit(1);
    }

    // Create the shared memory segment
    shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(1);
    }

    // Attach to the shared memory
    shm = shmat(shmid, NULL, 0);
    if (shm == (int *) -1) {
        perror("shmat");
        exit(1);
    }

    // Fork a child process to take input from the user
    pid_t pid_input = fork();

    if (pid_input == -1) {
        perror("fork");
        exit(1);
    }

    if (pid_input == 0) { // Child process (input)
        printf("Enter the number of elements: ");
        int num_elements;
        scanf("%d", &num_elements);

        printf("Enter %d numbers:\n", num_elements);
        for (int i = 0; i < num_elements; i++) {
            scanf("%d", &shm[i]);
        }

        // Detach from the shared memory
        if (shmdt(shm) == -1) {
            perror("shmdt");
            exit(1);
        }

        exit(0);
    } else { // Parent process (sort)
        wait(NULL); // Wait for the input process to complete

        // Fork another child process to sort the numbers
        pid_t pid_sort = fork();

        if (pid_sort == -1) {
            perror("fork");
            exit(1);
        }

        if (pid_sort == 0) { // Child process (sort)
            // Sort the numbers using bubble sort
            int temp;
            for (int i = 0; i < SHM_SIZE / sizeof(int); i++) {
                for (int j = 0; j < SHM_SIZE / sizeof(int) - i - 1; j++) {
                    if (shm[j] > shm[j + 1]) {
                        temp = shm[j];
                        shm[j] = shm[j + 1];
                        shm[j + 1] = temp;
                    }
                }
            }

            // Detach from the shared memory
            if (shmdt(shm) == -1) {
                perror("shmdt");
                exit(1);
            }

            exit(0);
        } else { // Parent process (display)
            wait(NULL); // Wait for the sort process to complete

            // Fork another child process to display the sorted numbers
            pid_t pid_display = fork();

            if (pid_display == -1) {
                perror("fork");
                exit(1);
            }

            if (pid_display == 0) { // Child process (display)
                printf("Sorted numbers:\n");
                for (int i = 0; i < SHM_SIZE / sizeof(int); i++) {
                    printf("%d ", shm[i]);
                }
                printf("\n");

                // Detach from the shared memory
                if (shmdt(shm) == -1) {
                    perror("shmdt");
                    exit(1);
                }

                exit(0);
            }
        }
    }

    // Wait for all child processes to complete
    wait(NULL);
    wait(NULL);
    wait(NULL);

    // Remove the shared memory segment
    shmctl(shmid, IPC_RMID, NULL);

    return 0;
}
/*
Commands
gcc -o shared_memory_sort shared_memory_sort.c
./shared_memory_sort

*/



44. Write a program in which different processes will perform different operation on shared
memory. Operation: create memory, delete, attach/ detach(using shmget, shmat, shmdt).
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/wait.h>

#define SHM_SIZE 1024

int main() {
    int shmid;
    key_t key;
    void *shm;

    // Create a unique key
    key = ftok(".", 's');
    if (key == -1) {
        perror("ftok");
        exit(1);
    }

    // Fork a child process to create shared memory
    pid_t pid_create = fork();

    if (pid_create == -1) {
        perror("fork");
        exit(1);
    }

    if (pid_create == 0) { // Child process (create)
        printf("Child process (create): Creating shared memory...\n");

        // Create the shared memory segment
        shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);
        if (shmid == -1) {
            perror("shmget");
            exit(1);
        }

        printf("Child process (create): Shared memory created with ID: %d\n", shmid);

        exit(0);
    } else { // Parent process (delete)
        wait(NULL); // Wait for the create process to complete

        // Fork another child process to delete shared memory
        pid_t pid_delete = fork();

        if (pid_delete == -1) {
            perror("fork");
            exit(1);
        }

        if (pid_delete == 0) { // Child process (delete)
            printf("Child process (delete): Deleting shared memory...\n");

            // Delete the shared memory segment
            if (shmctl(shmid, IPC_RMID, NULL) == -1) {
                perror("shmctl");
                exit(1);
            }

            printf("Child process (delete): Shared memory deleted\n");

            exit(0);
        } else { // Parent process (attach/detach)
            wait(NULL); // Wait for the delete process to complete

            // Fork another child process to attach/detach shared memory
            pid_t pid_attach_detach = fork();

            if (pid_attach_detach == -1) {
                perror("fork");
                exit(1);
            }

            if (pid_attach_detach == 0) { // Child process (attach/detach)
                printf("Child process (attach/detach): Attaching to shared memory...\n");

                // Attach to the shared memory
                shmid = shmget(key, SHM_SIZE, 0666);
                if (shmid == -1) {
                    perror("shmget");
                    exit(1);
                }

                shm = shmat(shmid, NULL, 0);
                if (shm == (void *) -1) {
                    perror("shmat");
                    exit(1);
                }

                printf("Child process (attach/detach): Attached to shared memory\n");

                // Wait for a while
                sleep(2);

                printf("Child process (attach/detach): Detaching from shared memory...\n");

                // Detach from the shared memory
                if (shmdt(shm) == -1) {
                    perror("shmdt");
                    exit(1);
                }

                printf("Child process (attach/detach): Detached from shared memory\n");

                exit(0);
            }
        }
    }

    // Wait for all child processes to complete
    wait(NULL);
    wait(NULL);
    wait(NULL);

    return 0;
}
/*
Commands to run
gcc -o shared_memory shared_memory.c
./shared_memory
*/

45. Write programs to simulate linux commands cat, ls, cp, mv, head etc.

/*
Commands to run
gcc -o cp cp.c
gcc -o head head.c
gcc -o ls ls.c
gcc -o mv mv.c


./cp source_file destination_file
./head [number_of_lines] [file_name]
./ls [directory_path]
./mv source_file destination_file


*/
//cat
#include <stdio.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <file1> [<file2> ...]\n", argv[0]);
        return 1;
    }

    for (int i = 1; i < argc; i++) {
        FILE *file = fopen(argv[i], "r");
        if (file == NULL) {
            printf("Error: Cannot open file %s\n", argv[i]);
            continue;
        }

        char c;
        while ((c = fgetc(file)) != EOF) {
            putchar(c);
        }

        fclose(file);
    }

    return 0;
}

// commands to run
/*
gcc -o cat cat.c
./cat file1.txt file2.txt

*/

//cp
#include <stdio.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: %s <source> <destination>\n", argv[0]);
        return 1;
    }

    FILE *source_file = fopen(argv[1], "r");
    if (source_file == NULL) {
        perror("fopen");
        return 1;
    }

    FILE *destination_file = fopen(argv[2], "w");
    if (destination_file == NULL) {
        perror("fopen");
        fclose(source_file);
        return 1;
    }

    char c;
    while ((c = fgetc(source_file)) != EOF) {
        fputc(c, destination_file);
    }

    fclose(source_file);
    fclose(destination_file);

    return 0;
}

//head
#include <stdio.h>

#define DEFAULT_NUM_LINES 10

int main(int argc, char *argv[]) {
    int num_lines = DEFAULT_NUM_LINES;
    if (argc > 1) {
        num_lines = atoi(argv[1]);
    }

    FILE *file = stdin;
    if (argc > 2) {
        file = fopen(argv[2], "r");
        if (file == NULL) {
            perror("fopen");
            return 1;
        }
    }

    int lines_printed = 0;
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), file) != NULL && lines_printed < num_lines) {
        fputs(buffer, stdout);
        lines_printed++;
    }

    if (file != stdin) {
        fclose(file);
    }

    return 0;
}


//ls
#include <stdio.h>
#include <dirent.h>

int main(int argc, char *argv[]) {
    const char *dir_path = argc > 1 ? argv[1] : ".";

    DIR *dir = opendir(dir_path);
    if (dir == NULL) {
        perror("opendir");
        return 1;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
    }

    closedir(dir);
    return 0;
}

//mv

#include <stdio.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: %s <source> <destination>\n", argv[0]);
        return 1;
    }

    if (rename(argv[1], argv[2]) == -1) {
        perror("rename");
        return 1;
    }

    return 0;
}


46. Write a program to ensure that function f1 should executed before executing function f2
using semaphore. (Ex. Program should ask for username before entering password)
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

// Define semaphores
sem_t sem_f1;
sem_t sem_f2;

void *f1(void *arg) {
    // Ask for username
    printf("Enter username: ");
    char username[100];
    scanf("%s", username);

    // Signal that f1 is done
    sem_post(&sem_f1);

    pthread_exit(NULL);
}

void *f2(void *arg) {
    // Wait for f1 to finish
    sem_wait(&sem_f1);

    // Now execute f2
    printf("Enter password: ");
    char password[100];
    scanf("%s", password);

    pthread_exit(NULL);
}

int main() {
    // Initialize semaphores
    sem_init(&sem_f1, 0, 0);
    sem_init(&sem_f2, 0, 0);

    // Create threads for f1 and f2
    pthread_t thread_f1, thread_f2;

    pthread_create(&thread_f1, NULL, f1, NULL);
    pthread_create(&thread_f2, NULL, f2, NULL);

    // Wait for threads to finish
    pthread_join(thread_f1, NULL);
    pthread_join(thread_f2, NULL);

    // Destroy semaphores
    sem_destroy(&sem_f1);
    sem_destroy(&sem_f2);

    return 0;
}

/*
gcc -o threads threads.c -pthread
./threads


*/


47. Write a program using OpenMP library to parallelize the for loop in sequential program
of finding prime numbers in given range.

#include <stdio.h>
#include <omp.h>

int is_prime(int n) {
    if (n <= 1) return 0;
    if (n <= 3) return 1;
    if (n % 2 == 0 || n % 3 == 0) return 0;

    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return 0;
    }

    return 1;
}

int main() {
    int lower = 1, upper = 100000;
    int num_primes = 0;

    #pragma omp parallel for reduction(+:num_primes)
    for (int i = lower; i <= upper; i++) {
        if (is_prime(i)) {
            num_primes++;
        }
    }

    printf("Number of prime numbers between %d and %d: %d\n", lower, upper, num_primes);

    return 0;
}

/*
gcc -o prime_numbers -fopenmp prime_numbers.c
./prime_numbers

*/


48. Using OpemnMP library write a program in which master thread count the total no. of
threads created, and others will print their thread numbers.
#include <stdio.h>
#include <omp.h>

int main() {
    int total_threads = 0;

    #pragma omp parallel
    {
        #pragma omp master
        {
            total_threads = omp_get_num_threads();
            printf("Total number of threads created: %d\n", total_threads);
        }

        int thread_num = omp_get_thread_num();
        printf("Thread %d reporting.\n", thread_num);
    }

    return 0;
}

/*
gcc -o thread_info -fopenmp thread_info.c
./thread_info

*/



49. Implement the program for IPC using MPI library (“Hello world” program).

#include <stdio.h>
#include <mpi.h>

int main(int argc, char *argv[]) {
    int rank, size;

    // Initialize MPI
    MPI_Init(&argc, &argv);

    // Get the rank of the current process
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    // Get the total number of processes
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    // Print "Hello world" from each process
    printf("Hello world from process %d out of %d\n", rank, size);

    // Finalize MPI
    MPI_Finalize();

    return 0;
}

/*
commands to run
sudo apt-get install openmpi-bin libopenmpi-dev

mpicc -o mpi_hello mpi_hello.c
mpirun -np 4 ./mpi_hello

*/
50. Write a 2 programs that will both send and messages and construct the following
dialog between them
(Process 1) Sends the message "Are you hearing me?"
(Process 2) Receives the message and replies "Loud and Clear".
(Process 1) Receives the reply and then says "I can hear you too".
IPC:Message Queues:msgget, msgsnd, msgrcv.

50.1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MAX 100

// Structure for message
struct msg_buffer {
    long msg_type;
    char msg_text[MAX];
};

int main() {
    key_t key;
    int msgid;
    struct msg_buffer message;

    // Generate unique key
    key = ftok("msgfile", 65);
    if (key == -1) {
        perror("ftok failed");
        exit(1);
    }

    // Create message queue
    msgid = msgget(key, 0666 | IPC_CREAT);
    if (msgid == -1) {
        perror("msgget failed");
        exit(1);
    }

    // Step 1: Send "Are you hearing me?" to Process 2 (type 1)
    message.msg_type = 1;
    strcpy(message.msg_text, "Are you hearing me?");
    msgsnd(msgid, &message, sizeof(message.msg_text), 0);
    printf("Process 1 sent: %s\n", message.msg_text);

    // Step 3: Receive reply from Process 2 (type 2)
    msgrcv(msgid, &message, sizeof(message.msg_text), 2, 0);
    printf("Process 1 received: %s\n", message.msg_text);

    // Step 4: Reply "I can hear you too" (type 2)
    strcpy(message.msg_text, "I can hear you too");
    message.msg_type = 2;
    msgsnd(msgid, &message, sizeof(message.msg_text), 0);
    printf("Process 1 sent: %s\n", message.msg_text);

    return 0;
}

50.2
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MAX 100

// Structure for message
struct msg_buffer {
    long msg_type;
    char msg_text[MAX];
};

int main() {
    key_t key;
    int msgid;
    struct msg_buffer message;

    // Generate the same key
    key = ftok("msgfile", 65);
    if (key == -1) {
        perror("ftok failed");
        exit(1);
    }

    // Access the message queue
    msgid = msgget(key, 0666);
    if (msgid == -1) {
        perror("msgget failed");
        exit(1);
    }

    // Step 2: Receive from Process 1 (type 1)
    msgrcv(msgid, &message, sizeof(message.msg_text), 1, 0);
    printf("Process 2 received: %s\n", message.msg_text);

    // Step 2: Reply "Loud and Clear" (type 2)
    message.msg_type = 2;
    strcpy(message.msg_text, "Loud and Clear");
    msgsnd(msgid, &message, sizeof(message.msg_text), 0);
    printf("Process 2 sent: %s\n", message.msg_text);

    // Step 5: Receive the final reply from Process 1 (type 2)
    msgrcv(msgid, &message, sizeof(message.msg_text), 2, 0);
    printf("Process 2 received: %s\n", message.msg_text);

    // Clean up: Remove message queue
    msgctl(msgid, IPC_RMID, NULL);

    return 0;
}



/*
commands to run
// open 2 terminals for 2 processes

gcc -o process1 process1.c
./process1

gcc -o process2 process2.c
./process2

*/



# till here there are 50 codes from now on there are 55 codes

Q 51. Write a program for TCP to demonstrate the socket system calls in c/python

Client

# tcp_client.py
import socket

HOST = '127.0.0.1'
PORT = 8080

# 1. Create socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. Connect to server
client_socket.connect((HOST, PORT))

# 3. Send and receive data
client_socket.sendall(b"Hello from client")
data = client_socket.recv(1024)

print(f"Message from server: {data.decode()}")

# 4. Close connection
client_socket.close()


server

# tcp_server.py
import socket

HOST = '127.0.0.1'  # Localhost
PORT = 8080         # Same port as client

# 1. Create socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. Bind socket
server_socket.bind((HOST, PORT))

# 3. Listen for connections
server_socket.listen()

print(f"Server listening on {HOST}:{PORT}")

# 4. Accept a connection
conn, addr = server_socket.accept()
print(f"Connected by {addr}")

# 5. Receive and send data
data = conn.recv(1024)
print(f"Message from client: {data.decode()}")
conn.sendall(b"Hello from server")

# 6. Close connection
conn.close()
server_socket.close()







Q 52.Write a program for UDP to demonstrate the socket system calls in c/python

Client

# udp_client.py
import socket

HOST = '127.0.0.1'
PORT = 8080

# 1. Create socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 2. Send and receive data
client_socket.sendto(b"Hello from client", (HOST, PORT))
data, server = client_socket.recvfrom(1024)

print(f"Received from server: {data.decode()}")

# 3. Close socket
client_socket.close()

Server

# udp_server.py
import socket

HOST = '127.0.0.1'
PORT = 8080

# 1. Create socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 2. Bind socket
server_socket.bind((HOST, PORT))

print(f"UDP Server listening on {HOST}:{PORT}")

# 3. Receive and send data
data, addr = server_socket.recvfrom(1024)
print(f"Received from client {addr}: {data.decode()}")

server_socket.sendto(b"Hello from server", addr)

# 4. Close socket
server_socket.close()



53.1 Implement echo server using TCP in iterative logic.

Client

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int sock = 0;
    struct sockaddr_in serv_addr;
    char buffer[BUFFER_SIZE] = {0};
    const char *message = "Hello from client";

    // Create socket
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Socket creation error");
        exit(EXIT_FAILURE);
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    // Convert IPv4 and IPv6 addresses from text to binary form
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        perror("Invalid address/ Address not supported");
        exit(EXIT_FAILURE);
    }

    // Connect to server
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("Connection failed");
        exit(EXIT_FAILURE);
    }

    // Send message to server
    send(sock, message, strlen(message), 0);
    printf("Message sent to server: %s\n", message);

    // Read message from server
    read(sock, buffer, BUFFER_SIZE);
    printf("Message from server: %s\n", buffer);

    return 0;
}


Server

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define MAX_CONNECTIONS 5
#define BUFFER_SIZE 1024

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};
    const char *message = "Echo from server: ";

    // Creating socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // Set socket options to reuse address and port
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    // Initialize address struct
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind socket to address
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_fd, MAX_CONNECTIONS) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    // Accept incoming connections and handle them iteratively
    while (1) {
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {
            perror("accept");
            exit(EXIT_FAILURE);
        }

        // Read data from client
        read(new_socket, buffer, BUFFER_SIZE);

        // Send data back to client
        send(new_socket, message, strlen(message), 0);
        send(new_socket, buffer, strlen(buffer), 0);
        printf("Message sent to client: %s\n", buffer);

        // Clear the buffer
        memset(buffer, 0, sizeof(buffer));

        // Close the socket
        close(new_socket);
    }
    return 0;
}

53.2 Implement echo server using TCP in concurrent logic.

Client

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024

// Function to handle sending and receiving data from server
void *handle_server(void *arg) {
    int client_socket = *((int *)arg);
    char buffer[BUFFER_SIZE];

    while (1) {
        // Receive data from server
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            printf("Server disconnected\n");
            close(client_socket);
            pthread_exit(NULL);
        }

        // Print received data
        printf("Server: %.*s", bytes_received, buffer);
    }
}

int main() {
    int client_socket;
    struct sockaddr_in server_address;
    pthread_t tid;

    // Create TCP socket
    client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Initialize server address
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_address.sin_port = htons(9999);

    // Connect to server
    if (connect(client_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        perror("Connection failed");
        exit(EXIT_FAILURE);
    }

    printf("Connected to server\n");

    // Create a new thread to handle receiving data from server
    if (pthread_create(&tid, NULL, handle_server, (void *)&client_socket) != 0) {
        perror("Thread creation failed");
        close(client_socket);
        exit(EXIT_FAILURE);
    }

    // Main loop to send data to server
    char input_buffer[BUFFER_SIZE];
    while (1) {
        fgets(input_buffer, BUFFER_SIZE, stdin);
        if (strcmp(input_buffer, "disconnect\n") == 0) {
            printf("Disconnecting from server\n");
            close(client_socket);
            break;
        }
        // Send data to server
        send(client_socket, input_buffer, strlen(input_buffer), 0);
    }

    return 0;
}

Server

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 5
#define BUFFER_SIZE 1024

// Structure to hold client information
typedef struct {
    int client_socket;
    struct sockaddr_in client_address;
} client_info;

// Function to handle client connections
void *handle_client(void *arg) {
    client_info *client = (client_info *)arg;
    char buffer[BUFFER_SIZE];

    printf("Accepted connection from %s:%d\n", inet_ntoa(client->client_address.sin_addr), ntohs(client->client_address.sin_port));

    while (1) {
        // Receive data from client
        int bytes_received = recv(client->client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            printf("Connection from %s:%d closed\n", inet_ntoa(client->client_address.sin_addr), ntohs(client->client_address.sin_port));
            close(client->client_socket);
            free(client);
            pthread_exit(NULL);
        }

        // Echo back the received data
        send(client->client_socket, buffer, bytes_received, 0);
    }
}

int main() {
    int server_socket, client_socket;
    struct sockaddr_in server_address, client_address;
    pthread_t tid[MAX_CLIENTS];
    int client_count = 0;

    // Create TCP socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Initialize server address
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);
    server_address.sin_port = htons(9999);

    // Bind socket to address
    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        perror("Bind failed");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        perror("Listen failed");
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port 9999...\n");

    while (1) {
        // Accept incoming connection
        socklen_t client_address_len = sizeof(client_address);
        client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_len);
        if (client_socket == -1) {
            perror("Accept failed");
            continue;
        }

        // Create a new thread to handle client
        client_info *client = (client_info *)malloc(sizeof(client_info));
        if (client == NULL) {
            perror("Memory allocation failed");
            continue;
        }
        client->client_socket = client_socket;
        client->client_address = client_address;
        if (pthread_create(&tid[client_count++], NULL, handle_client, (void *)client) != 0) {
            perror("Thread creation failed");
            free(client);
            continue;
        }

        // Limit the number of clients
        if (client_count >= MAX_CLIENTS) {
            printf("Maximum number of clients reached. No longer accepting connections.\n");
            break;
        }
    }

    // Wait for all threads to finish
    for (int i = 0; i < client_count; i++) {
        pthread_join(tid[i], NULL);
    }

    // Close server socket
    close(server_socket);

    return 0;
}



54.1 Implement echo server using UDP in iterative logic.

Client
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define PORT 9999
#define BUFFER_SIZE 4096

int main() {
    struct sockaddr_in server_addr;
    int sockfd;
    char buffer[BUFFER_SIZE];
    socklen_t server_len;

    // Create a UDP socket
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Initialize server address structure
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    while (1) {
        printf("Enter message to send (type 'exit' to quit): ");
        fgets(buffer, BUFFER_SIZE, stdin);

        // Remove newline character from the input
        buffer[strcspn(buffer, "\n")] = 0;

        if (strcmp(buffer, "exit") == 0) {
            break;
        }

        // Send message to the server
        server_len = sizeof(server_addr);
        if (sendto(sockfd, buffer, strlen(buffer), 0, (struct sockaddr*)&server_addr, server_len) < 0) {
            perror("sendto failed");
            exit(EXIT_FAILURE);
        }

        // Receive response from server
        if (recvfrom(sockfd, buffer, BUFFER_SIZE, 0, NULL, NULL) < 0) {
            perror("recvfrom failed");
            exit(EXIT_FAILURE);
        }

        printf("Received response: %s\n", buffer);
    }

    // Close the socket
    close(sockfd);

    return 0;
}




Server
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define PORT 9999
#define BUFFER_SIZE 4096

int main() {
    struct sockaddr_in server_addr, client_addr;
    int sockfd, client_len, recv_len;
    char buffer[BUFFER_SIZE];

    // Create a UDP socket
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Initialize server address structure
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Bind the socket
    if (bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    printf("Server is running on port %d\n", PORT);

    while (1) {
        printf("\nWaiting to receive message...\n");

        // Receive message from client
        client_len = sizeof(client_addr);
        if ((recv_len = recvfrom(sockfd, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, &client_len)) < 0) {
            perror("recvfrom failed");
            exit(EXIT_FAILURE);
        }

        printf("Received %d bytes from %s:%d\n", recv_len, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        printf("Data received: %s\n", buffer);

        // Echo back the received data
        if (sendto(sockfd, buffer, recv_len, 0, (struct sockaddr*)&client_addr, client_len) < 0) {
            perror("sendto failed");
            exit(EXIT_FAILURE);
        }
    }

    return 0;
}


54.2 Implement echo server using UDP in concurrent logic.

Client
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define MAXLINE 1024

int main() {
    int sockfd;
    char buffer[MAXLINE];
    struct sockaddr_in servaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));

    // Filling server information
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(PORT);
    servaddr.sin_addr.s_addr = INADDR_ANY;

    int n, len;

    while (1) {
        printf("Enter message: ");
        fgets(buffer, MAXLINE, stdin);
        sendto(sockfd, (const char *)buffer, strlen(buffer), MSG_CONFIRM, (const struct sockaddr *)&servaddr, sizeof(servaddr));
        n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, (struct sockaddr *)&servaddr, &len);
        buffer[n] = '\0';
        printf("Server : %s\n", buffer);
    }

    close(sockfd);
    return 0;
}

Server
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define MAXLINE 1024

int main() {
    int sockfd;
    char buffer[MAXLINE];
    struct sockaddr_in servaddr, cliaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    // Filling server information
    servaddr.sin_family = AF_INET; // IPv4
    servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(PORT);

    // Bind the socket with the server address
    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    printf("Server is listening on port %d\n", PORT);

    int len, n;
    len = sizeof(cliaddr);  //len is value/resuslt

    while (1) {
        n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, (struct sockaddr *)&cliaddr, &len);
        buffer[n] = '\0';
        printf("Client : %s\n", buffer);
        sendto(sockfd, (const char *)buffer, strlen(buffer), MSG_CONFIRM, (const struct sockaddr *)&cliaddr, len);
    }

    return 0;
}




assignment55

// Write a program using PIPE, to Send data from parent to child over a pipe (unnamed pipe). 

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h> // ✅ Needed for pid_t
#include <sys/wait.h>  // ✅ Needed for wait()

int main() {
    int pipefd[2];   // pipefd[0] -> Read end, pipefd[1] -> Write end
    pid_t pid;
    char write_msg[] = "Hello Child, this is Parent!";
    char read_msg[100];

    // 1. Create the pipe
    if (pipe(pipefd) == -1) {
        perror("Pipe failed");
        exit(EXIT_FAILURE);
    }

    // 2. Fork a child process
    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid > 0) {
        // Parent process
        close(pipefd[0]); // Close the read end

        // Write message to the pipe
        write(pipefd[1], write_msg, strlen(write_msg) + 1);
        close(pipefd[1]); // Close the write end after writing

        wait(NULL); // Wait for child to finish
    }
    else {
        // Child process
        close(pipefd[1]); // Close the write end

        // Read message from the pipe
        read(pipefd[0], read_msg, sizeof(read_msg));
        printf("Child received message: %s\n", read_msg);
        close(pipefd[0]); // Close the read end
    }

    return 0;
}



//56. Write a program using FIFO, to Send data from parent to child over a pipe. (named pipe)


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>      // For open()
#include <sys/types.h>  // For mkfifo(), pid_t
#include <sys/stat.h>   // For mkfifo()
#include <sys/wait.h>   // For wait()

#define FIFO_NAME "myfifo"

int main() {
    int fd;
    pid_t pid;
    char write_msg[] = "Hello Child, this is Parent via FIFO!";
    char read_msg[100];

    // 1. Create the FIFO (named pipe)
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        perror("mkfifo failed");
        // Not exiting; maybe it already exists
    }

    // 2. Fork a child process
    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid > 0) {
        // Parent process
        fd = open(FIFO_NAME, O_WRONLY); // Open FIFO for writing only

        write(fd, write_msg, strlen(write_msg) + 1);
        close(fd);

        wait(NULL); // Wait for child
    }
    else {
        // Child process
        fd = open(FIFO_NAME, O_RDONLY); // Open FIFO for reading only

        read(fd, read_msg, sizeof(read_msg));
        printf("Child received message: %s\n", read_msg);
        close(fd);
    }

    // 3. Remove the FIFO after communication
    if (pid > 0) {
        unlink(FIFO_NAME);
    }

    return 0;
}


57. Write a program using PIPE, to Send file from parent to child over a pipe.
(unnamed pipe )
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>      // For open()
#include <sys/types.h>  // For pid_t
#include <sys/wait.h>   // For wait()

#define BUFFER_SIZE 1024

int main() {
    int pipefd[2];
    pid_t pid;
    char buffer[BUFFER_SIZE];
    int file_fd;
    ssize_t bytes_read;

    // 1. Create pipe
    if (pipe(pipefd) == -1) {
        perror("Pipe creation failed");
        exit(EXIT_FAILURE);
    }

    // 2. Fork a child process
    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid > 0) {
        // Parent process
        close(pipefd[0]); // Close reading end

        // Open the file to read
        file_fd = open("input.txt", O_RDONLY);
        if (file_fd < 0) {
            perror("Failed to open file");
            exit(EXIT_FAILURE);
        }

        // Read from file and write into pipe
        while ((bytes_read = read(file_fd, buffer, sizeof(buffer))) > 0) {
            write(pipefd[1], buffer, bytes_read);
        }

        close(file_fd);
        close(pipefd[1]); // Close writing end after sending file

        wait(NULL); // Wait for child to finish
    }
    else {
        // Child process
        close(pipefd[1]); // Close writing end

        printf("Child received file content:\n");

        // Read from pipe and print to stdout
        while ((bytes_read = read(pipefd[0], buffer, sizeof(buffer))) > 0) {
            write(STDOUT_FILENO, buffer, bytes_read);
        }
        printf("\n");
        close(pipefd[0]); // Close reading end
    }

    return 0;
}



58. Write a program using FIFO, to Send file from parent to child over a pipe. (named
pipe)


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>      // open()
#include <sys/types.h>  // mkfifo(), pid_t
#include <sys/stat.h>   // mkfifo()
#include <sys/wait.h>   // wait()

#define FIFO_NAME "myfifo"
#define BUFFER_SIZE 1024

int main() {
    int fd;
    pid_t pid;
    char buffer[BUFFER_SIZE];
    int file_fd;
    ssize_t bytes_read;

    // 1. Create the FIFO (named pipe)
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        perror("mkfifo failed");
        // Not exiting; maybe it already exists
    }

    // 2. Fork a child process
    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid > 0) {
        // Parent process
        fd = open(FIFO_NAME, O_WRONLY); // Open FIFO for writing

        // Open the file to read
        file_fd = open("input.txt", O_RDONLY);
        if (file_fd < 0) {
            perror("Failed to open file");
            exit(EXIT_FAILURE);
        }

        // Read from file and write into FIFO
        while ((bytes_read = read(file_fd, buffer, sizeof(buffer))) > 0) {
            write(fd, buffer, bytes_read);
        }

        close(file_fd);
        close(fd);

        wait(NULL); // Wait for child to finish

        unlink(FIFO_NAME); // Remove FIFO file after use
    }
    else {
        // Child process
        fd = open(FIFO_NAME, O_RDONLY); // Open FIFO for reading

        printf("Child received file content:\n\n");

        // Read from FIFO and display to stdout
        while ((bytes_read = read(fd, buffer, sizeof(buffer))) > 0) {
            write(STDOUT_FILENO, buffer, bytes_read);
        }
        printf("\n");
        close(fd);
    }

    return 0;
}


59. Write a program using PIPE, to convert uppercase to lowercase filter to read command/
from file

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>      // For tolower()
#include <string.h>
#include <fcntl.h>      // For open()
#include <sys/types.h>  // For pid_t
#include <sys/wait.h>   // For wait()

#define BUFFER_SIZE 1024

int main() {
    int pipefd[2];
    pid_t pid;
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read;
    int file_fd;

    // 1. Create pipe
    if (pipe(pipefd) == -1) {
        perror("Pipe creation failed");
        exit(EXIT_FAILURE);
    }

    // 2. Fork a child process
    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid > 0) {
        // Parent process
        close(pipefd[0]); // Close reading end

        // Open file or command output
        file_fd = open("input.txt", O_RDONLY);
        if (file_fd < 0) {
            perror("Failed to open file");
            exit(EXIT_FAILURE);
        }

        // Read from file and write to pipe
        while ((bytes_read = read(file_fd, buffer, sizeof(buffer))) > 0) {
            write(pipefd[1], buffer, bytes_read);
        }

        close(file_fd);
        close(pipefd[1]); // Close writing end after sending
        wait(NULL); // Wait for child to complete
    }
    else {
        // Child process
        close(pipefd[1]); // Close writing end

        // Read from pipe, convert to lowercase and output
        printf("Child output (converted to lowercase):\n\n");
        while ((bytes_read = read(pipefd[0], buffer, sizeof(buffer))) > 0) {
            for (int i = 0; i < bytes_read; i++) {
                buffer[i] = tolower(buffer[i]);
            }
            write(STDOUT_FILENO, buffer, bytes_read);
        }

        close(pipefd[0]);
    }

    return 0;
}




60.Write a program to illustrate the semaphore concept. Use fork so that 2 process running
simultaneously and communicate via semaphore. (give diff between sem.h/semaphore.h)

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h> 
#include <sys/ipc.h>    // For IPC (semaphore)
#include <sys/sem.h>    // For semaphores
#include <sys/wait.h>   // For wait()

// Union semun is needed for setting semaphore value
union semun {
    int val;                // value for SETVAL
    struct semid_ds *buf;    // buffer for IPC_STAT, IPC_SET
    unsigned short *array;   // array for GETALL, SETALL
};

void wait_semaphore(int semid) {
    struct sembuf sops = {0, -1, 0}; // Decrement by 1
    semop(semid, &sops, 1);
}

void signal_semaphore(int semid) {
    struct sembuf sops = {0, 1, 0}; // Increment by 1
    semop(semid, &sops, 1);
}

int main() {
    int semid;
    pid_t pid;

    // 1. Create a semaphore
    semid = semget(IPC_PRIVATE, 1, IPC_CREAT | 0666);
    if (semid == -1) {
        perror("semget failed");
        exit(EXIT_FAILURE);
    }

    // 2. Initialize semaphore to 1
    union semun sem_union;
    sem_union.val = 1; // binary semaphore (1 = available)
    if (semctl(semid, 0, SETVAL, sem_union) == -1) {
        perror("semctl failed");
        exit(EXIT_FAILURE);
    }

    // 3. Fork process
    pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid == 0) {
        // Child process
        wait_semaphore(semid); // Wait (lock)
        for (int i = 0; i < 5; i++) {
            printf("Child process running... [%d]\n", i);
            sleep(1);
        }
        signal_semaphore(semid); // Signal (unlock)
        exit(0);
    }
    else {
        // Parent process
        wait_semaphore(semid); // Wait (lock)
        for (int i = 0; i < 5; i++) {
            printf("Parent process running... [%d]\n", i);
            sleep(1);
        }
        signal_semaphore(semid); // Signal (unlock)
        wait(NULL); // Wait for child to finish

        // 4. Cleanup semaphore
        semctl(semid, 0, IPC_RMID);
    }

    return 0;
}



61. Write 3 programs separately, 1st program will initialize the semaphore and display the
semaphore ID. 2nd program will perform the P operation and print message accordingly. 3rd
program will perform the V operation print the message accordingly for the same
semaphore declared in the 1st program.



program1: nto run process 

Program to initialize the semaphore and display its ID:

// File: sem_init.c

#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/sem.h>

// Define a union as required by semctl
union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int main() {
    key_t key;
    int semid;
    union semun sem_union;

    // Generate a unique key
    key = ftok("semfile", 'A'); 
    if (key == -1) {
        perror("ftok failed");
        exit(EXIT_FAILURE);
    }

    // Create a semaphore
    semid = semget(key, 1, IPC_CREAT | 0666);
    if (semid == -1) {
        perror("semget failed");
        exit(EXIT_FAILURE);
    }

    // Initialize semaphore value to 1
    sem_union.val = 1;
    if (semctl(semid, 0, SETVAL, sem_union) == -1) {
        perror("semctl failed");
        exit(EXIT_FAILURE);
    }

    printf("Semaphore initialized. Semaphore ID = %d\n", semid);

    return 0;
}

Program to perform the "P" operation (wait) on the semaphore:
c
Copy code
// File: sem_p.c

#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/sem.h>

// Structure for semaphore operations
struct sembuf p_op = {0, -1, 0}; // P operation (decrement)

int main() {
    key_t key;
    int semid;

    // Generate the same key
    key = ftok("semfile", 'A');
    if (key == -1) {
        perror("ftok failed");
        exit(EXIT_FAILURE);
    }

    // Get the semaphore
    semid = semget(key, 1, 0666);
    if (semid == -1) {
        perror("semget failed");
        exit(EXIT_FAILURE);
    }

    // Perform P operation
    printf("Trying to perform P (wait) operation...\n");
    if (semop(semid, &p_op, 1) == -1) {
        perror("semop (P) failed");
        exit(EXIT_FAILURE);
    }

    printf("P (wait) operation successful. Semaphore resource acquired.\n");

    return 0;
}



perform v operation

// File: sem_v.c

#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/sem.h>

// Structure for semaphore operations
struct sembuf v_op = {0, 1, 0}; // V operation (increment)

int main() {
    key_t key;
    int semid;

    // Generate the same key
    key = ftok("semfile", 'A');
    if (key == -1) {
        perror("ftok failed");
        exit(EXIT_FAILURE);
    }

    // Get the semaphore
    semid = semget(key, 1, 0666);
    if (semid == -1) {
        perror("semget failed");
        exit(EXIT_FAILURE);
    }

    // Perform V operation
    printf("Trying to perform V (signal) operation...\n");
    if (semop(semid, &v_op, 1) == -1) {
        perror("semop (V) failed");
        exit(EXIT_FAILURE);
    }

    printf("V (signal) operation successful. Semaphore resource released.\n");

    return 0;
}

 command:gcc initialize_semaphore.cpp -o initialize_semaphore
gcc perform_P_operation.cpp -o perform_P_operation
gcc perform_V_operation.cpp -o perform_V_operation

execution:
./initialize_semaphore
./perform_P_operation
./perform_V_operation



62. Write a program to demonstrate the lockf system call for locking.

// File: lockf_example.c

#define _XOPEN_SOURCE 500

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>    // For open()
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int fd;
    pid_t pid;

    // Open a file for read and write
    fd = open("lockfile.txt", O_CREAT | O_RDWR, 0666);
    if (fd == -1) {
        perror("open failed");
        exit(EXIT_FAILURE);
    }

    // Write some initial content
    write(fd, "Initial file content\n", 22);

    // Fork a child
    pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid == 0) {
        // Child process
        printf("Child trying to acquire lock...\n");

        // Attempt to lock the file
        if (lockf(fd, F_LOCK, 0) == -1) {
            perror("Child: lockf failed");
            exit(EXIT_FAILURE);
        }

        printf("Child acquired lock! Writing to file...\n");
        write(fd, "Child was here!\n", 16);
        sleep(5);  // Simulate some processing

        // Unlock the file
        if (lockf(fd, F_ULOCK, 0) == -1) {
            perror("Child: unlock failed");
            exit(EXIT_FAILURE);
        }

        printf("Child released lock.\n");
        close(fd);
    }
    else {
        // Parent process
        sleep(1); // Let child try first
        printf("Parent trying to acquire lock...\n");

        if (lockf(fd, F_LOCK, 0) == -1) {
            perror("Parent: lockf failed");
            exit(EXIT_FAILURE);
        }

        printf("Parent acquired lock! Writing to file...\n");
        write(fd, "Parent was here!\n", 17);

        if (lockf(fd, F_ULOCK, 0) == -1) {
            perror("Parent: unlock failed");
            exit(EXIT_FAILURE);
        }

        printf("Parent released lock.\n");
        close(fd);

        wait(NULL); // Wait for child
    }

    return 0;
}

63. Write a program to demonstrate the flock system call for locking.


// File: flock_example_fixed.c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>      // open()
#include <sys/file.h>   // flock()
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int fd;
    pid_t pid;

    // Open the file: create if not exists, truncate it to zero size
    fd = open("flockfile.txt", O_CREAT | O_RDWR | O_TRUNC, 0666);
    if (fd == -1) {
        perror("open failed");
        exit(EXIT_FAILURE);
    }

    // Fork a new process
    pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(EXIT_FAILURE);
    }
    else if (pid == 0) {
        // ------------------------
        // Child Process
        // ------------------------
        close(fd);  // Close inherited fd
        fd = open("flockfile.txt", O_RDWR);  // Re-open file separately

        printf("Child trying to acquire exclusive lock...\n");

        if (flock(fd, LOCK_EX) == -1) {
            perror("Child: flock failed");
            exit(EXIT_FAILURE);
        }

        printf("Child acquired lock! Writing to file...\n");

        lseek(fd, 0, SEEK_END); // Move to end before writing
        write(fd, "Child process was here!\n", 24);
        sleep(5);  // Hold lock for some time

        if (flock(fd, LOCK_UN) == -1) {
            perror("Child: unlock failed");
            exit(EXIT_FAILURE);
        }

        printf("Child released lock.\n");
        close(fd);
    }
    else {
        // ------------------------
        // Parent Process
        // ------------------------
        close(fd);  // Close inherited fd
        fd = open("flockfile.txt", O_RDWR);  // Re-open file separately

        sleep(1); // Give child time to lock and write
        printf("Parent trying to acquire exclusive lock...\n");

        if (flock(fd, LOCK_EX) == -1) {
            perror("Parent: flock failed");
            exit(EXIT_FAILURE);
        }

        printf("Parent acquired lock! Writing to file...\n");

        lseek(fd, 0, SEEK_END); // Move to end before writing
        write(fd, "Parent process was here!\n", 25);

        if (flock(fd, LOCK_UN) == -1) {
            perror("Parent: unlock failed");
            exit(EXIT_FAILURE);
        }

        printf("Parent released lock.\n");
        close(fd);

        wait(NULL); // Wait for child
    }

    return 0;
}





64. Using FIFO as named pipe use read and write system calls to establish communication
(IPC) between two ends.
// using fifo as named pipe use read and write system calls to establish communication (IPC) between two ends

64a.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define FIFO_NAME "/tmp/my_fifo"

int main() {
    int fifo_fd;

    // Create FIFO
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        perror("mkfifo");
        exit(EXIT_FAILURE);
    }

    printf("FIFO created successfully\n");

    // Open FIFO for writing
    fifo_fd = open(FIFO_NAME, O_WRONLY);
    if (fifo_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    printf("FIFO opened for writing\n");

    // Write data to FIFO
    const char *message = "Hello from Writer";
    if (write(fifo_fd, message, sizeof(message)) == -1) {
        perror("write");
        exit(EXIT_FAILURE);
    }

    printf("Data written to FIFO\n");

    // Close FIFO
    close(fifo_fd);

    return 0;
}

64b.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define FIFO_NAME "/tmp/my_fifo"

int main() {
    int fifo_fd;
    char buf[256];

    // Open FIFO for reading
    fifo_fd = open(FIFO_NAME, O_RDONLY);
    if (fifo_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    printf("FIFO opened for reading\n");

    // Read data from FIFO
    ssize_t num_bytes = read(fifo_fd, buf, sizeof(buf));
    if (num_bytes == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }

    // Null-terminate the received data
    buf[num_bytes] = '\0';

    printf("Received message: %s\n", buf);

    // Close FIFO
    close(fifo_fd);

    return 0;
}

65 write shell script with FIFO/mknod (named pipe) us for communication (IPC)

sender
#!/bin/bash

# Define the named pipe
PIPE=/tmp/my_fifo

# Create the named pipe if it doesn't exist
if [ ! -p $PIPE ]; then
    mkfifo $PIPE
fi

# Check if the receiver script is running
if ! pgrep -x "receiver.sh" > /dev/null; then
    echo "Receiver script is not running. Please start the receiver script before sending messages."
    exit 1
fi

# Prompt user to enter message
echo "Enter message to send (Press Ctrl+D to exit):"
while IFS= read -r line; do
    # Send message through the named pipe
    echo "$line" > $PIPE
done

reciever
#!/bin/bash

# Define the named pipe
PIPE=/tmp/my_fifo

# Create the named pipe if it doesn't exist
if [ ! -p $PIPE ]; then
    mkfifo $PIPE
fi

# Infinite loop to continuously listen for messages
while true; do
    # Read message from the named pipe
    if read line < $PIPE; then
        echo "Received message: $line"
    fi
done

Both scripts first define a named pipe (FIFO) path (/tmp/my_fifo).
They check if the named pipe already exists; if not, they create it using mkfifo.
The sender script (sender.sh) checks if the receiver script (receiver.sh) is running. If not, it prompts the user to start the receiver script first.
The sender script continuously reads input from the user and sends it to the named pipe.
The receiver script (receiver.sh) continuously listens for messages from the named pipe and displays them.
To use these scripts:

Save the sender script as sender.sh and the receiver script as receiver.sh.
Make both scripts executable: chmod +x sender.sh receiver.sh.
Open two terminal windows or tabs.
In one terminal, run the receiver script: ./receiver.sh.
In the other terminal, run the sender script: ./sender.sh.
Enter messages in the sender terminal, and they should be received and displayed by the receiver.





66 write prog using FIFO/mknod (named pipe)/unmanned pipe for uppercase to lowercase to
conversion

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>

int main() {
    int pipefd[2]; // File descriptors for the pipe
    int nbytes; // Number of bytes read from the pipe
    pid_t pid;
    char readbuffer[80]; // Buffer to read data from the pipe

    // Create the pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Fork a child process
    pid = fork();

    if (pid < 0) { // Error occurred
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid > 0) { // Parent process
        close(pipefd[0]); // Close the read end of the pipe

        // Write data to the pipe
        printf("Enter text: ");
        fgets(readbuffer, sizeof(readbuffer), stdin);
        write(pipefd[1], readbuffer, sizeof(readbuffer));
        close(pipefd[1]); // Close the write end of the pipe
    } 
    else { // Child process
        close(pipefd[1]); // Close the write end of the pipe
        nbytes = read(pipefd[0], readbuffer, sizeof(readbuffer)); // Read data from the pipe

        for (int i = 0; i < nbytes; i++) {
            readbuffer[i] = tolower(readbuffer[i]); // Convert to lowercase
        }

        printf("Lowercase text: %s", readbuffer);
        close(pipefd[0]); // Close the read end of the pipe
    }

    return 0;
}















